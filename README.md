# LINUX
## LOG INTO LOACL AND REMOTE CONSOLES
* **Vertual Terminal:** A built-in feature of the Linux operating system that allows users to access multiple windows terminal sessions from a single physical console, press `ctrl+alt+F2`
* **Console:** A system console is the device which receives all kernel messages and warnings and which allows logins in single user mode
* **Terminal Emulator:** A computer program that emulates a video terminal within some other display architecture
* To get all ip addresses associated with your system, run `ip a`
* To ssh into a system, run `ssh USER@IP_HOST_NAME -p PORT`

## READ SYSTEM DOCS
* `COMMAND --help`
* `man COMMAND`
* Many tools and files have doc at `/usr/share/doc/`
* `man man`
* `man 1 printf`
* `appropos ROUGH_COMMAND`, to search for a command, but before running this initialize a database using `sudo mandb`

## SAFELY BOOT REBOOT
* `sudo systemctl reboot`
* `sudo systemctl poweroff`
* `sudo systemctl reboot --force` forcefully reboot
* `sudo systemctl poweroff --force` forcefullt poweroff
* `sudo systemctl reboot --force --force` very insecure, its like pulling power cable from computer
* `sudo systemctl poweroff --force --force` very insecure, its like pulling power cable from computer
* `sudo shutdown 18:15` power off at 18:15
* `sudo shutdown +15` power off in 15 mins
* `sudo shutdown -r +15` reboot after 15 mins
* `sudo shutdown -r +10 'Rebooting system wall message'` notify logged in users what is about to happen

## BOOT SYSTEM IN DIFFERENT MODES
* When we boot into the system, we boot into the `default.target`
* We can see the default target using `systemctl get-default`
* `graphical.target` is for booting into GUI mode, `multi-user.target` is for booting into the linux shell target (the black box screen)
* We can change the default target using `systemctl set-default multi-user.target`
* Switch back to graphical target from the `multi-user.target` `systemctl isolate graphical.target`, this is not permanant, it is only for the current session
* `emargency.target` is for debugging the boot process and other problems that are caused by different systems, this also marks the root fs as read-only
* `rescue.target` only essential services are loaded and we are logged into root shell

## SHELL AUTOMATION
* `chmod +x FILE` make executable for everyone
* `chmod u+x FILE` make executable for current user

## MANAGE STARTUP PROCESSES
* Processe are started by a init system
* Systemd is a collection of tools that helps start, operate and manage services and processes, it is also a init system
* `systemctl cat SYSTEMD_FILE` to see the systemd file content
* `systemctl edit --full SYSTEMD_FILE` to edit the systemd file
* `systemctl revert SYSTEMD_FILE` to revert the changes to the file to factory settings
* `systemctl status SERVICE_NAME` to see status of service
* `systemctl stop SERVICE_NAME` to stop a service
* `systemctl start SERVICE_NAME` to start a service
* `systemctl restart SERVICE_NAME` to sestart a service but this can abrupt the current process that may be associated with other processes and users
* `systemctl reload SERVICE_NAME` reload service without interrupting the processes and in-memory data
* `systemctl disable SERVICE_NAME` to disable the service
* `systemctl enable SERVICE_NAME` to enable the service
* `systemctl enable --now SERVICE_NAME` enable and start the service
* `systemctl disbale --now SERVICE_NAME` disable and stop the service
* `systemctl mask SERVICE_NAME` sometimes a service starts automatically and starts other serivices too, to stop this thing we need to mask the service
* `systemctl unmask SERVICE_NAME` to unmask the masked service
* `systemctl list-units --type UNIT_TYPE --all` to list all serices of a type, there are many types of services: `service`, `socket` etc

## SYSTEMD SERVICES
* `man systemd.<TAB><TAB>` to get to know about service units
* See pre existing systemd files at `/lib/systemd/system`
* `journalctl -f` to see live logs generated by systemd services

## DIAGNOSE and MANAGE PROCESSES
* `man ps /EXAMPLES` see most used `ps` examples
* `ps` list processes running in current terminal session
* `ps -aux` list all processes
* Processes shown in bracket area are privilaged processes running in kernel mode
* `ps u PID` see process data in user oriented format (see process cpu and mem utilisation)
* `ps u -U USER_NAME` see processes launched by current user in user oriented format
* `pgrep -a MATCH_STRING` search process by name or match_string
* there are enice values thich can define process priority [-20, 19], more the value, less the cpu it consumes
* `nice -n NICE_VALUE COMMAND` run a process with a nice value
* `ps l` see processes with nice values
* `ps fax` see all processes with child parent relationship
* `renice NEW_NICE_VALUE PID` change nice value
* `kill -L` get list of signals for processes
* `kill -SIGNAL PID` send a signal to the process
* `pkill -SIGNAL PROCESS_NAME` send signal to all processes matching the name
* `COMMAND &` run process in background
* `fg PROCESS_HINT` bring back the process in foreground
* `lsof -p PID` see all files and directories being used by a process
* `lsof FILE_DIRECTORY_PATH` see if any process is using the file or directory

## LOG FILES
* `rsyslog` saves all the logs in `/var/log/`
* `grep -r ssh /var/log/` get file that strores ssh logs
* Main files that are frequently used are `/var/log/syslog` and `/var/log/auth.log`
* `tail -F LOGFILE` see live logs
* `journalctl COMMAND_SYSTEMD_UNIT` see logs generated by the command
* `journalctl -f` see live logs
* `journalctl -p PRIORITY`, see logs filtered by priority, priorities are: `info`, `warning`, `err` and `crit`
* `journalctl -p PRIORITY -g 'REGEX'` see regex matching logs with selected priority
* `journalctl -S START_TIME -U END_TIME` see logs in between time period, time format is `HH:MM`
* `journalctl -b 0` get loge for current boot
* `journalctl -b -N` see logs for previous boots
* `last` see login activity
* `lastlog` see who logged last

## SCHEDULING TASKS
* We can schedule tasks using cron, anacron and at
* Anacron runs the task even if the computer was off at the time of execution but cron won't
* `cat /etc/crontab` to see the cronjob format
* For each star if we want to run in ranges or multiple values of theat field, we can use:
    - , to match multiple values without having space inbetween the value and comma (like 2,5)
    - \- for specifying the ranges (like 2-4)
    - / can be used to specify the step values (skip values) (like /4)
* Always use full command path
* Cronjobs are user specific
* `sudo cronjob -e -u USERNAME` edit other user's cronjobs
* `at` command is used to run a task once
| COMMAND | EFFECT |
| ------- | ------ |
| `at '15:35'` | run a tast at a praticular time |
| `at '12:34 August 20 2024'` | run task at specific date and time |
| `at 'now + 30  minutes'` | run 30 minutes later |

## PACKAGE MANAGEMENT
* Specifically for apt package manger
* `apt search --name PACKKAGE_NAME` to search package in module names and their descriptions
* `apt search --names-only PACKKAGE_NAME` to search only in module names
* `apt install PACKKAGE_NAME` to install a package
* `apt remove PACKKAGE_NAME` to remove package, but do not remove dependencies
* `apt autoremove PACKKAGE_NAME` to remove the dependencies along with the main package
* The file `/etc/apt/sources.list.d/ubuntu.sources` stores all the repositories that apt is supposed to search and use


## VERIFY AVAILABILITY OF RESOURCES
* `df` see the disk free space
* `df -h` see the disk space in human readable format
* `du -sh PATH` see the space being used by a directory
* `free -h` see available ram and swap
* `uptime` see system isge throughout the boot time
* `fsck.ext4 -v -f -p PATH_TO_DISK_DEVICE` repair disk with verbose, force and pre options

## CHANGE KERNEL RUNTIME PARAMETERS (PERSISTENT and NON PERSISTENT)
* `sysctl -a` read some parameter values
* `sysctl -w PARAMETER=VALUE` write values to a parameter, non presistent change
* `man sysctl.d` get help on system parameter configuration files
* We can also edit the pre existing file `/etc/sysctl.conf`
### MAKE PERSISTENT CHANGE
* Make a file `touch /etc/sysctl.d/FILE_NAME.conf`, we can give any name
* Add the line `vm.swappiness=20` and then save, this makes the vm lss swappy
* This will persist even after reboot
* These changes normally apply after reboot, to get into action quickly run `sysctl -p /etc/sysctl.d/FILE_NAME.conf`

## CREATE DELETE MODIFY USER and GROUPS
| COMMAND | EFFECT |
| ------- | ------ |
| `adduser USER_NAME` | Creates a user, also creates a new group called USER_NAME |
| `passwd USER_NAME` | Change or enter a new password |
| `deluser USER_NAME` | Delete a user, but if someone else is in its group, group stays and /home/USER_NAME is not removed |
| `adduser --shell /bin/OTHER_SHELL --home /home/OTHER_DIRECTORY USER_NAME` | Specify alternative shall and home directory |
| `cat /etc/passwd` | See account details |
| `adduser --uid UID USER_NAME` | Specify UID |
| `ls -la` | Get user and owner permissions |
| `ls -lna` | Get user and owner premissions in UID |
| `id` | Get current user info |
| `useradd --system --no-create-home USER_NAME` | Create a system account without home directory |
| `usermod --home /home/OTHER_DIRECTORY --move-home USER_NAME` | Change the home directory of a user |
| `usermod --login NEW_USER_NAME OLD_USER_NAME` | Change username |
| `usermod --shell /bin/OTHER_SHELL USER_NAME` | Change default shell |
| `usermod --lock USER_NAME` | Lock/Disable the account without deleting it |
| `usermod --unlock USER_NAME` | Unlock the account |
| `usermod --expiredate YYYY-MM-DD USER_NAME` | Expire the account on date, can be re-enabled |
| `chage --maxdays N USER_NAME` | Force user to change the password every N days |
| `chage --maxdays -1 USER_NAME` | Make user password never expires |
| `chage --lastday 0 USER_NAME` | Expire user password for the user |
| `chage --lastday -1 USER_NAME` | Unexpire the user password |
| `groupadd GROUP_NAME` | Create a group |
| `gpasswd --add USER_NAME GROUP_NAME` | Add user to group |
| `gpasswd --delete USER_NAME GROUP_NAME` | Remove a user from group |
| `groups USER_NAME` | See the groups that the user is part of |
| `usermod -g GROUP_NAME USER_NAME` | Change primary group of user |
| `usermod -G GROUP_NAME USER_NAME` | Change secondary group of user |
| `groupmod --new-name NEW_GROUP_NAME OLD_GROUP_NAME` | Change group name |
| `groupdel GROUP_NAME` | Delete group, but be careful, no user should have this group as primary |

## MANAGE ENVIRONMENT PROFILES
* To save variables in local profile, save them in `/home/usr/.bashrc`
* To save variables in all profiles, save then in `/etc/environment`
* To run a task when a user logs in, create a file `/etc/profile.d/FILE_NAME.sh` and add all the commands that are need to be run
| COMMAND | EFFECT |
| ------- | ------ |
| `printenv` | List environment parameters |
| `echo $ENV_VARIABLE` | Print environment variable value |

## MANAGE TEMPLATE USER ENVIRONMENT
* When a user is created, all items from `/etc/skel/` are copied to new user's home directory
* We put all the files in there and they will be copied

## USER RESOURCE LIMITS
* To do this we can edit `/etc/security/limits.conf`
* Syntax for Each entry is `DOMAIN LIMIT_TYPE RESOURCE_ITEM VALUE`
* `DOMAIN` could be `USER_NAME` or `@GROUP_NAME`, and `*` is for all users not mentioned specifically in the entries of this file
* `LIMIT_TYPE` could be hard, soft or \-
    - `hard` is used for max value that can ever be used
    - `soft` is used for startup resource limits
    - \- is used for both hard and soft limit, it defines both as same value
* `RESOURCE_ITEM` defines type fo resource to limit (like nproc, cpu, fsize)
* To seek for more help `man limits.conf`

## MANAGE USER PRIVILAGES
* Most of the users are in the sudo group and can run all the commands after entering the password, but this is a issue
* To solve this we need to edit the `/etc/sudoers`
* The systax for the sudoers file is `USER IP_HOST_NAME=(RUN_AS_USER:RUN_AS_GROUP) LIST_OF_COMMANDS_THAT_ARE_ALLOWED_TO_BE_EXECUTED`
* All parameters except the `USER` can be entered with comma seperated without space
* Examples
    - `USER1 ALL=(USER2,USER3) /bin/COMMAND1, /bin/COMMAND2`, this allows USER1 to run COMMAND1 and COMMAND2 as sudo as USER2 and USER3
    - `USER_NAME ALL=NOPASSWD:ALL`, this allow running sudo commands wothout password
    - `%GROUP_NAME ALL=(ALL) ALL`

* To run a command as other user `sudo -u USER_NAME COMMAND ARGUMENTS`

## MANAGE ACCESS TO ROOT ACCOUNT
* In some systems, root account is locked for security purposes but this does not mean we can't login with the root
| COMMAND | EFFECT |
| ------- | ------ |
| `sudo --login` | Login into the shell as root user |
| `su -` | Login into the shell as root user, we need to enter the root user password insteat of the current user |
| `sudo passwd --unlock root` | Unlock the root user |
| `sudo passwd root` | Change or create a password for root |
| `passwd --lock root` | Everyone using root is insecure, so we lock the password based logins |

## CONFIGURE IPv4 and IPv6 NETWORKING and HOSTNAME RESOLUTION
* IPv6 and IPv4 both have a CIDR notation
* IPv6 addresses can be written in short by removing leading zeroes (`2001:0db8:0000:0000:0000:ff00:0042:8378` \-> `2001:db8::ff0042:8378`)
* The `ip` command can help us get all important info about our network configuration
* A network interface can have multiple IPs, sometimes they need to be removed or added
#### CHANGE SYSTEMWIDE DNS
* To apply nameserver setting to all network interfaces, edit `/etc/systemd/resolved.conf` and add the following `DNS=IP_ADDRESSES`, `IP_ADDRESSES` are the IP addresses seperated by spaces and then restart the systemd resolver daemon by running `systemctl restart systemd-resolver.service`
#### REFER INTERNAL HOSTS BY NAME
* Sometimes we have a internal server for some purposes, we cant remember all the IP addresses, so we add he names of servers in the file `/etc/hosts`
* We make an entry in the format `IP NAME` 

| COMMAND | EFFECT |
| ------- | ------ |
| `ip link` | Shows all networking interfaces on the device |
| `ip -c address` | Shows ip addresses for all the networking interfaces |
| `ip link set dev INTERFACE_NAME up` | Activate a networking interface connection |
| `ip link set dev INTERFACE_NAME down` | Deactivate a networking interface connection |
| `ip addr add CIDR dev INTERFACE_NAME` | Manually add IPv4 address, specify the address and add an IP, CIDR example is `192.168.1.9/24` |
| `ip addr add IPv6_CIDR INTERFACE_NAME` | Manually add IPv6 address, specify the address and add an IP, CIDR examples is `fe80::5054:ff:fe1f:8050/64` |
| `ip addr delete CIDR dev INTERFACE_NAME` | Remove a IP address from an interface, after this we need to bring back the device down |
| `ip route` | See the routes to different destinations |
| `resolvectl status` | See the nameserver configuration for all the interfaces |
| `systectl restart systemd-resolver.service` | Restart the DNS resolver daemon to apply changes in `/etc/systemd/resolved.conf` |

* All these changes are temporary, to make these changes permanent, we use netplan
* The netplan files is present at `/etc/netplan/`, we can edit those or create our own
* New file's name will be in format `NN-NAME.yaml`, where NN are single digit numbers
* Then see a already existing file and start making changes according to ahat we need
* The DHCP server loop runs on the router
* Netplan files might look like these for wireless interfaces
```
network:
  version: 2
  wifis:
    NM-325453d5-9061-49ab-ae2a-1f8f8f9f01bf:
      renderer: NetworkManager
      match:
        name: "wlp0s20f3"
      dhcp4: true
      dhcp6: true
      access-points:
        "POCO C65":
          auth:
            key-management: "psk"
            password: "avadakadabra"
          networkmanager:
            uuid: "325453d5-9061-49ab-ae2a-1f8f8f9f01bf"
            name: "POCO C65"
            passthrough:
              wifi-security.auth-alg: "open"
              ipv6.addr-gen-mode: "default"
              ipv6.ip6-privacy: "-1"
              proxy._: ""
      networkmanager:
        uuid: "325453d5-9061-49ab-ae2a-1f8f8f9f01bf"
        name: "POCO C65"
```
| COMMAND | EFFECT |
| ------- | ------ |
| `netplan get` | Get all info for all network interfaces |
| `netplan try` | Try the changes defined in the netplan file |
| `netplan apply` | Aply changes made to netplan file |

* Lets configure the file with a ethernet device
```
network:
  ethernets:
    enp0s8:
      dhcp4: false
      dhcp6: false
      addresses:
        - 192.168.1.9/24
        - f380::921b:eff:fe3d:abcd/64
      nameservers:
        addresses:
          - 8.8.4.4
          - 8.8.8.8
      routes:
        - to: 192.168.0.0/24
          via: 10.0.0.100
        - to: default
          via: 10.0.0.1
  version: 2
```
* We can get great netplan examples at `/usr/share/doc/netplan/examples/`
* For more help `man netplan`, `man ip`

## START STOP and MANAGE NETWORK SERVICES
| COMMAND | EFFECT |
| ------- | ------ |
| `ss -ltunp` | Tells which interface and and ports are being used in the system |
| `netatst -ltunp` | same as that command above |

## PORT REDIRECTION and NAT
* Port forwarding allows remote servers and devices on the internet to be able to access devices that are on a private network
* We can enable port forwarding in linux by editing `/etc/sysctl.conf` or `/etc/sysctl.d/99-sysctl.conf`, editing the first one is riskier
* Open the second file and add or uncomment the following lines
```
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
```
* Generally input and output network interfaes and input network interfaces are different but can be same in some cases
* After editing the file reload all sysctl config files by running `sudo sysctl --system`
* For adding fine tuned working rules in nat table we need to do both pre routing and post routing things
| COMMAND | EFFECT |
| ------- | ------ |
| `ip r` | See all the routes |
| `iptables -t nat -A PREROUTING -i INPUT_INTERFACE_NAME -s SOURCE_CIDR -p tcp --dport DESTINATION_PORT -j DNAT --to-destination IP_HOST_NAME:PORT` | Add a rule to NAT table in append manner with prerouting packet modification to jump the packets in DNAT manner |
| `iptables -t nat -A POSTROUTING -s SOURCE_CIDR -o OUTPUT_INTERFACE_NAME -j MASQUERADE` | Add a rule to nat table for masquerading with post routing |
| `iptables --list-rules --table nat` | See all nat rules |
| `iptables --flush --table nat` | Delete all the rules from the nat table |

* All the changes made by these command are temporary and are lost at next boot up, to make these changes permanent install a package `iptables-persistent` from apt and after adding the rule to chain, run `netfilter-persistent save`

* This stuff can be done using ufw too
| COMMAND | EFFECT |
| ------- | ------ |
| `ufw route allow from INPUT_CIDR to TARGET_MACHINE_IP` | Allow port forwarding |

## SYNCHRONIZE SYSTEM TIME
* Our systems can utilize time servers to get exact time from the internet
| COMMAND | EFFECT |
| ------- | ------ |
| `timedatectl list-timezones` | Get all available timezones |
| `timedatectl set-timezone TIMEZONE` | Set system timezone |
| `timedatectl` | Get timezone and system time info and see if any NTP server is active |
| `apt install systemd-timesyncd && timedatectl set-ntp true` | If no active NTP servers found, we turn on synchronization with NTP servers |
| `systemctl status systemd-timesyncd.service` | See if NTP service is actine or not |





























## VIRTUAL MACHINES
* Install `virsh` a cli tool to manage virtual machines
* Install `virt-manager` `apt install virt-manager`
* Now vreate a configuration file with `.xml` extension, let it be `huhu.xml` and put the following content in it
```
<domain type="qemu">
    <name>TEST</name>
    <memory unit="GiB">1</memory>
    <vcpu>1</vcpu>
    <os>
        <type arch="x86_64">hvm</type>
    </os>
</domain>
```
* `virish define huhu.xml` to create a virtual machine
* `virsh list` to list running virtual machines
* `virsh list --all` to list all virtual machines
* `virsh start MACHINE_NAME` to start the machine
* `virsh reboot MACHINE_NAME` to reboot the machine
* `virsh reset MACHINE_NAME` to reset the machine
* `virsh shutdown MACHINE_NAME` to gracefully shut the machine
* `virsh destroy MACHINE_NAME` to forcefully shut the virtual machine
* `virsh autostart MACHINE_NAME` to enable autostarting the machine
* `virsh autostart --disable MACHINE_NAME` to disable autostart the machine
* `virsh dominfo MACHINE_NAME` to get domain info about the machine
* `virsh setvcpus MACHINE_NAME N --config --maximum` to change allcated vcpus to machine
* `virsh setmaxmem MACHINE_NAME 2048M --config` change maximum memory limit
* `virsh setmem MACHINE_NAME 2048M --config` change memory allocated to machine

### INSTALLING OS IN VIRTUAL MACHINE
* Install minimal image of ubuntu from a url looking similar to `cloud-images.ubuntu.com/minimal/releases/noble/release`
* To download image `wget http://cloud-images.ubuntu.com/minimal/releases/noble/release/ubuntu-24.04-minimal-cloudimg-amd64.img`
* To download checksum `wget http://cloud-images.ubuntu.com/minimal/releases/noble/release/SHA256SUMS`
* To check if the file was downloaded correctly `sha256sum -c SHA256SUMS 2>&1 | grep OK`
* To see info regarding the image `qemo-img info IMAGE_PATH`
* Virtual size of the disk is the `disk size` that will be configured in the virtual machine while we install the os in the virtual machine
* To change the `disk size` run `qemu-img resize IMAGE_PATH 10G`
* There is a storage pool where all snapshots of machines and other data related to them will be stored, by default these are `/var/lib/libvirt/`
* Copy the image into the pool directory `sudo IMAGE_PATH /var/lib/libvirt/images/`
* Run `virt-install --osinfo list` to get list of type of os to select
* To create a virtual machine `virt-install --osinfo ubuntu24.04 --name NAME --memory 1024 --vcpus 1 --import --disk /var/lib/libvirt/images/IMAGE_NAME --graphics none`
* To get root password add these parematers in the command above `--cloud-init root-password-generate=on`
* We can again connect to the virtual machine after exiting by `virsh console ubuntu1`
* To autodetect OS info in the `--osinfo` parameter we can pass `detect=on`


